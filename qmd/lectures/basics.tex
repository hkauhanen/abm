% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrartcl}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Programming basics},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Programming basics}
\author{}
\date{2024-04-16}

\begin{document}
\maketitle

\subsection{TUDÃš}\label{tuduxfa}

\begin{itemize}
\tightlist
\item
  comments
\item
  packages
\item
  functions vs methods (multiple dispatch)
\item
  meaning of dynamic typing
\item
  custom types
\item
  broadcasting of functions
\item
  array comprehensions
\item
  explicit type declarations for custom types and function arguments
\item
  conditionals
\item
  loops
\end{itemize}

\subsection{Variables and assignments}\label{variables-and-assignments}

\begin{itemize}
\tightlist
\item
  In programming, a \textbf{variable} is a ``storage box'' that stores
  data for later use
\item
  The data is \textbf{assigned} to the variable using the \texttt{=}
  operator
\item
  Here, we assign the number 5 to a variable named \texttt{my\_number}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_number }\OperatorTok{=} \FloatTok{5}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  We can now do things such as:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_number }\OperatorTok{+}\NormalTok{ my\_number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

\subsection{Fundamental types}\label{fundamental-types}

\begin{itemize}
\tightlist
\item
  Variables can store different \textbf{types} of data:

  \begin{itemize}
  \tightlist
  \item
    Integers: \texttt{1}, \texttt{2}, \texttt{-100}, \ldots{}
  \item
    Floating-point numbers (``floats''): \texttt{3.14}, \texttt{pi},
    \texttt{1.0}, \ldots{}
  \item
    Booleans: \texttt{true}, \texttt{false}
  \item
    Strings: \texttt{"John"}, \texttt{"Mary"}
  \item
    Arrays: \texttt{{[}1,\ 2,\ 3,\ 4{]}}, \texttt{{[}1\ 2\ 3\ 4{]}}
  \item
    And some others\ldots{} we'll meet them later
  \end{itemize}
\end{itemize}

\subsection{Arithmetic operations}\label{arithmetic-operations}

\begin{itemize}
\tightlist
\item
  Arithmetic operations are mostly self-explanatory. For example:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number1 }\OperatorTok{=} \FloatTok{15}
\NormalTok{number2 }\OperatorTok{=} \FloatTok{20}
\NormalTok{number3 }\OperatorTok{=} \FloatTok{10}\FunctionTok{*}\NormalTok{(number1 }\OperatorTok{+}\NormalTok{ number2) }\OperatorTok{{-}}\NormalTok{ number1}\OperatorTok{/}\NormalTok{number2}
\NormalTok{number3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
349.25
\end{verbatim}

\subsection{String concatenation}\label{string-concatenation}

\begin{itemize}
\tightlist
\item
  Julia overloads the \texttt{*} operator for strings too:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{string1 }\OperatorTok{=} \StringTok{"This "}
\NormalTok{string2 }\OperatorTok{=} \StringTok{"is a"}
\NormalTok{string3 }\OperatorTok{=} \StringTok{" sentence"}
\NormalTok{string1 }\OperatorTok{*}\NormalTok{ string2 }\OperatorTok{*}\NormalTok{ string3 }\OperatorTok{*} \StringTok{"!"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"This is a sentence!"
\end{verbatim}

\subsection{Arrays}\label{arrays}

\begin{itemize}
\tightlist
\item
  An array is a (possibly multidimensional) collection of objects

  \begin{itemize}
  \tightlist
  \item
    A one-dimensional array is a vector, a two-dimensional array is a
    matrix, and so on
  \end{itemize}
\item
  Usually we work with arrays of numbers. They are easy to create:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array }\OperatorTok{=}\NormalTok{ [}\FloatTok{10}\NormalTok{, }\FloatTok{20}\NormalTok{, }\FloatTok{30}\NormalTok{, }\FloatTok{40}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Int64}:
 10
 20
 30
 40
\end{verbatim}

\subsection{Accessing array contents}\label{accessing-array-contents}

\begin{itemize}
\tightlist
\item
  The elements of an array can be accessed one-by-one by referencing
  their location or \textbf{index} in the array:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array }\OperatorTok{=}\NormalTok{ [}\FloatTok{10}\NormalTok{, }\FloatTok{20}\NormalTok{, }\FloatTok{30}\NormalTok{, }\FloatTok{40}\NormalTok{]}
\NormalTok{my\_array[}\FloatTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

or

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array[}\FloatTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  The special keyword \texttt{end} fetches the last element:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array[}\KeywordTok{end}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
40
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Arrays can also be subsetted:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array[}\FloatTok{2}\OperatorTok{:}\FloatTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2-element Vector{Int64}:
 20
 30
\end{verbatim}

\subsection{Broadcasting}\label{broadcasting}

\begin{itemize}
\tightlist
\item
  Suppose I want to add \texttt{1} to each number in \texttt{my\_array}
\item
  The following will \textbf{not} work:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array }\OperatorTok{+} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: MethodError: no method matching +(::Vector{Int64}, ::Int64)
For element-wise addition, use broadcasting with dot syntax: array .+ scalar

[0mClosest candidates are:
[0m  +(::Any, ::Any, [91m::Any[39m, [91m::Any...[39m)
[0m[90m   @[39m [90mBase[39m [90m[4moperators.jl:587[24m[39m
[0m  +([91m::Missing[39m, ::Number)
[0m[90m   @[39m [90mBase[39m [90m[4mmissing.jl:123[24m[39m
[0m  +([91m::P[39m, ::S) where {S<:Number, T, X, P<:Polynomials.FactoredPolynomial{T, X}}
[0m[90m   @[39m [35mPolynomials[39m [90m~/.julia/packages/Polynomials/5ZhzG/src/polynomials/[39m[90m[4mfactored_polynomial.jl:257[24m[39m
[0m  ...
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Why? Because mathematically the operation ``add a scalar into a
  vector'' is undefined
\item
  To apply an operator \textbf{elementwise} to each element in an array,
  we can prefix the operator with a period. In Julia-speak, this is
  called \textbf{broadcasting}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array }\OperatorTok{.+} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Int64}:
 11
 21
 31
 41
\end{verbatim}

\subsection{Type mismatch}\label{type-mismatch}

\begin{itemize}
\tightlist
\item
  Why does the following not work?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_string }\OperatorTok{=} \StringTok{"My shoe size is: "}
\NormalTok{my\_number }\OperatorTok{=} \FloatTok{41}
\NormalTok{my\_string }\OperatorTok{*}\NormalTok{ my\_number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
LoadError: MethodError: no method matching *(::String, ::Int64)

[0mClosest candidates are:
[0m  *(::Any, ::Any, [91m::Any[39m, [91m::Any...[39m)
[0m[90m   @[39m [90mBase[39m [90m[4moperators.jl:587[24m[39m
[0m  *([91m::Missing[39m, ::Number)
[0m[90m   @[39m [90mBase[39m [90m[4mmissing.jl:123[24m[39m
[0m  *([91m::Polynomials.AbstractPolynomial[39m, ::Union{Number, Matrix})
[0m[90m   @[39m [35mPolynomials[39m [90m~/.julia/packages/Polynomials/5ZhzG/src/[39m[90m[4mcommon.jl:1041[24m[39m
[0m  ...
\end{verbatim}

\begin{itemize}
\tightlist
\item
  To make it work, we need to explicitly \textbf{convert} the integer
  into a string:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_string }\OperatorTok{*} \FunctionTok{string}\NormalTok{(my\_number)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"My shoe size is: 41"
\end{verbatim}

\subsection{Functions}\label{functions}

\begin{itemize}
\tightlist
\item
  A \textbf{function}, sometimes also known as a \textbf{subroutine}, is
  a \textbf{reusable} piece of code that performs, well, some
  function\ldots{}
\item
  We define it once and then can use it as many times as we like
\item
  A function can (but need not) take inputs -- these are known as the
  function's \textbf{arguments}
\item
  A function can (but need not) give an output -- this is known as the
  function's \textbf{return value}
\end{itemize}

\subsection{Functions: example}\label{functions-example}

\begin{itemize}
\tightlist
\item
  Here is a function that takes two arguments, an array and a scalar
  number, and adds the scalar to each element of the array
\item
  I'm calling the function \texttt{add\_elementwise}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{add\_elementwise}\NormalTok{(array, scalar)}
\NormalTok{  result }\OperatorTok{=}\NormalTok{ array }\OperatorTok{.+}\NormalTok{ scalar}
  \ControlFlowTok{return}\NormalTok{ result}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
add_elementwise (generic function with 1 method)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  We can now \textbf{call} the function on particular arrays and
  numbers:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array }\OperatorTok{=}\NormalTok{ [}\FloatTok{10}\NormalTok{, }\FloatTok{20}\NormalTok{, }\FloatTok{30}\NormalTok{, }\FloatTok{40}\NormalTok{]}
\FunctionTok{add\_elementwise}\NormalTok{(my\_array, }\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Int64}:
 11
 21
 31
 41
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{add\_elementwise}\NormalTok{(my\_array, }\OperatorTok{{-}}\FloatTok{23.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4-element Vector{Float64}:
 -13.5
  -3.5
   6.5
  16.5
\end{verbatim}

\subsection{Exercise}\label{exercise}

Write a function with the following properties:

\begin{itemize}
\tightlist
\item
  The function's name is \texttt{announce\_age}
\item
  The function takes two arguments, the first a person's name, the
  second a number that is that person's age
\item
  The function's return value is a string which announces the person's
  age in this format: \texttt{"John\ is\ 40\ years\ old"}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-tip-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Answer}]

Here is the function definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{announce\_age}\NormalTok{(name, age)}
  \ControlFlowTok{return}\NormalTok{ name }\OperatorTok{*} \StringTok{" is "} \OperatorTok{*} \FunctionTok{string}\NormalTok{(age) }\OperatorTok{*} \StringTok{" years old"}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
announce_age (generic function with 1 method)
\end{verbatim}

Let's test it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{announce\_age}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\FloatTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"John is 40 years old"
\end{verbatim}

\end{tcolorbox}

\subsection{Custom types (``classes'' and
``objects'')}\label{custom-types-classes-and-objects}

\begin{itemize}
\tightlist
\item
  Idea of \textbf{object-oriented programming} (OOP): we can make custom
  types (\textbf{classes}) which are instantiated as \textbf{objects}

  \begin{itemize}
  \tightlist
  \item
    Programming ABMs in a language that does not support this would be
    very cumbersome
  \end{itemize}
\item
  In Julia, custom types are defined by way of a special keyword,
  \texttt{struct}
\item
  A custom type is effectively a combination of variables called the
  type's \textbf{fields}
\item
  If the fields need to be modifiable later in the program, we use
  \texttt{mutable\ struct} instead of \texttt{struct}
\end{itemize}

\subsection{Custom types: example}\label{custom-types-example}

\begin{itemize}
\tightlist
\item
  Suppose we want to represent a person by way of their name, their age
  and their shoe size
\item
  Since these fields (at least age) need to be modifiable, we use a
  \texttt{mutable\ struct}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mutable struct}\NormalTok{ Person}
\NormalTok{  name}\OperatorTok{::}\DataTypeTok{String}
\NormalTok{  age}\OperatorTok{::}\DataTypeTok{Int}
\NormalTok{  shoesize}\OperatorTok{::}\DataTypeTok{Float64}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Here,

  \begin{itemize}
  \tightlist
  \item
    \texttt{name::String} means the field called \texttt{name} is of
    type string, etc.
  \item
    \texttt{Int} is an integer
  \item
    in \texttt{Float64}, the number specifies the precision of the
    floating-point number (related to how many decimals it can store)
  \end{itemize}
\end{itemize}

\begin{itemize}
\tightlist
\item
  We can now \textbf{construct} an instance of the \texttt{Person}
  custom type, a \texttt{Person} object, and store it in a variable:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{jane }\OperatorTok{=} \FunctionTok{Person}\NormalTok{(}\StringTok{"Jane"}\NormalTok{, }\FloatTok{35}\NormalTok{, }\FloatTok{39.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Person("Jane", 35, 39.5)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  To \textbf{access} the fields of an object, we use the following dot
  syntax:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{jane.name}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Jane"
\end{verbatim}

\subsection{Exercise}\label{exercise-2}

Write three functions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A function that takes a \texttt{Person} object as argument and returns
  their shoe size
\item
  A function that takes a \texttt{Person} object and a string as
  argument, and sets the person's name to be the string supplied as
  argument
\item
  A function that increments a \texttt{Person} object's age by one
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-tip-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Answer}]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{get\_shoesize}\NormalTok{(x)}
  \ControlFlowTok{return}\NormalTok{ x.shoesize}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{set\_name}\NormalTok{(x, y)}
\NormalTok{  x.name }\OperatorTok{=}\NormalTok{ y}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{become\_older}\NormalTok{(x)}
\NormalTok{  x.age }\OperatorTok{=}\NormalTok{ x.age }\OperatorTok{+} \FloatTok{1}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\subsection{Explicit type
specifications}\label{explicit-type-specifications}

Note that it is possible (and often good practice) to explicitly set the
types of function arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{get\_shoesize}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Person}\NormalTok{)}
  \ControlFlowTok{return}\NormalTok{ x.shoesize}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{set\_name}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Person}\NormalTok{, y}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}
\NormalTok{  x.name }\OperatorTok{=}\NormalTok{ y}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{become\_older}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Person}\NormalTok{)}
\NormalTok{  x.age }\OperatorTok{=}\NormalTok{ x.age }\OperatorTok{+} \FloatTok{1}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Getters and setters}\label{getters-and-setters}

\begin{itemize}
\tightlist
\item
  Functions that return an object's field are sometimes known as
  \textbf{getters}. Functions that set a field are known as
  \textbf{setters}.
\item
  In Julia, it is customary to append an exclamation point to the name
  of every setter function. This is to warn users of the function that
  the function modifies something in the object.
\item
  Thus, we would rather write:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{set\_name!}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Person}\NormalTok{, y}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}
\NormalTok{  x.name }\OperatorTok{=}\NormalTok{ y}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Array comprehensions}\label{array-comprehensions}

\begin{itemize}
\tightlist
\item
  What if we wanted to create 3 \texttt{Person}s? Easy:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{person1 }\OperatorTok{=} \FunctionTok{Person}\NormalTok{(}\StringTok{"Jane"}\NormalTok{, }\FloatTok{35}\NormalTok{, }\FloatTok{39.5}\NormalTok{)}
\NormalTok{person2 }\OperatorTok{=} \FunctionTok{Person}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\FloatTok{44}\NormalTok{, }\FloatTok{43.0}\NormalTok{)}
\NormalTok{person3 }\OperatorTok{=} \FunctionTok{Person}\NormalTok{(}\StringTok{"Bob"}\NormalTok{, }\FloatTok{65}\NormalTok{, }\FloatTok{42.33}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Person("Bob", 65, 42.33)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  What if we wanted to create 1000 \texttt{Person}s?
\end{itemize}

\begin{itemize}
\tightlist
\item
  Here we can use a powerful feature known as an \textbf{array
  comprehension}. The following creates 1000 persons, each with the same
  default fields (we'll later see how to modify this), and places them
  in an array. The array is returned and stored in the
  \texttt{population} variable:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{population }\OperatorTok{=}\NormalTok{ [}\FunctionTok{Person}\NormalTok{(}\StringTok{"M. Musterperson"}\NormalTok{, }\FloatTok{0}\NormalTok{, }\FloatTok{0.0}\NormalTok{) for i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FloatTok{1000}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The \texttt{i} variable is a dummy variable that only exists for the
  duration of the array comprehension.
\end{itemize}

\begin{itemize}
\tightlist
\item
  We can now access individual persons by indexing them from the array:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{population[}\FloatTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Person("M. Musterperson", 0, 0.0)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  We can also access their fields:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{population[}\FloatTok{1}\NormalTok{].name}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"M. Musterperson"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  And we can set them:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set\_name}\NormalTok{(population[}\FloatTok{1}\NormalTok{], }\StringTok{"Bob the Builder"}\NormalTok{)}
\NormalTok{population[}\FloatTok{1}\NormalTok{].name}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Bob the Builder"
\end{verbatim}

\subsection{Random numbers}\label{random-numbers}

\begin{itemize}
\tightlist
\item
  To get a (pseudo)random number from between 0 and 1, simply call:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rand}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.656887270338244
\end{verbatim}

\subsection{Exercise}\label{exercise-4}

How can you obtain a random number from between 0 and 50?

How about between 50 and 100?

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-tip-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Answer}]

Random number from between 0 and 50:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{50}\FunctionTok{*rand}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.8574258877893444
\end{verbatim}

Random number from between 50 and 100:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{50} \OperatorTok{+} \FloatTok{50}\FunctionTok{*rand}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
52.49230886307882
\end{verbatim}

\end{tcolorbox}

\subsection{FIXME}\label{fixme}

control flow -- conditionals and loops?

or is this too much infooos for one session?

\subsection{Comments}\label{comments}

\begin{itemize}
\tightlist
\item
  To improve code readability, we insert comments (these are ignored by
  the compiler)
\item
  Single-line comment:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# the following variable stores my shoe size}
\NormalTok{shoesize }\OperatorTok{=} \FloatTok{41.5}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Multi-line comment:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#=}
\CommentTok{The following variable}
\CommentTok{stores my shoe size}
\CommentTok{=\#}
\NormalTok{shoesize }\OperatorTok{=} \FloatTok{41.5}
\end{Highlighting}
\end{Shaded}

\subsection{Packages}\label{packages}

\begin{itemize}
\tightlist
\item
  Basic Julia functionality is extended by \textbf{packages}
\item
  These are installed through a package manager called \textbf{Pkg}
\item
  E.g. to install the \emph{Agents} package (and all its dependencies),
  we issue these commands:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Pkg}
\BuiltInTok{Pkg}\NormalTok{.}\FunctionTok{add}\NormalTok{(}\StringTok{"Agents"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Once the package has been installed, we can load it by:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Agents}
\end{Highlighting}
\end{Shaded}

\subsection{Homework}\label{homework}

FIXME

\subsection{OLD}\label{old}

\subsection{Arrays and broadcasting}\label{arrays-and-broadcasting}

To represent a tuple (or vector) of numbers, we can make an
\textbf{array}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{manynumbers }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{4}\NormalTok{, }\FloatTok{6}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{20}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

The contents of an array can be fetched one by one, if necessary, or
subsetted:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{manynumbers[}\FloatTok{2}\NormalTok{] }\CommentTok{\# equals 4}
\NormalTok{manynumbers[}\FloatTok{2}\OperatorTok{:}\FloatTok{3}\NormalTok{] }\CommentTok{\# equals [4, 6]}
\end{Highlighting}
\end{Shaded}

The special keyword \texttt{end} fetches the last item in an array:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{manynumbers[}\KeywordTok{end}\NormalTok{] }\CommentTok{\# equals 20}
\end{Highlighting}
\end{Shaded}

Operations and functions (we'll talk about functions below) in Julia can
be \textbf{broadcast}, meaning that they are applied elementwise to all
elements in an array. To take a simple example, suppose we want to add 1
to each element in our array of integers, \texttt{manynumbers}. The
following won't do, because we'd be trying to add a scalar to a vector,
something that isn't mathematically defined:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{manynumbers }\OperatorTok{+} \FloatTok{1} \CommentTok{\# will throw an error}
\end{Highlighting}
\end{Shaded}

The following \emph{will} work, but is cumbersome to write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{manynumbers }\OperatorTok{+}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
  2
  5
  7
  3
 21
\end{verbatim}

Instead of this, we can use the special \texttt{.} prefix to apply the
sum operation elementwise:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{manynumbers }\OperatorTok{.+} \FloatTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5-element Vector{Int64}:
  2
  5
  7
  3
 21
\end{verbatim}

Note how the output is exactly the same.

\subsection{Custom types}\label{custom-types}

Sometimes basic types aren't quite enough. For example, suppose we want
to simulate the behaviour of a speaker--listener, i.e.~an agent that has
some representation of language and can interact with other agents. Is
it an integer? A floating-point number? A string? It isn't really any of
these. What we want to do is to be able to define our own data
structure, our own type.

For example, suppose that we can represent a speaker's grammar as an
integer (on the assumption that we index all grammars with the natural
numbers). Suppose, moreover, that we are interested in a speaker's age
as well as its social class. Then we might want a data type such as the
following, called a \textbf{composite type} in Julia:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mutable struct}\NormalTok{ Speaker}
\NormalTok{  grammar}\OperatorTok{::}\DataTypeTok{Int}
\NormalTok{  age}\OperatorTok{::}\DataTypeTok{Float64}
\NormalTok{  class}\OperatorTok{::}\DataTypeTok{String}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

In this definition, we introduce a composite type consisting of three
primitive type inside it: a \texttt{grammar}, an \texttt{age}, and a
(social) \texttt{class}. The first is declared to be an integer, the
second a floating-point number with 64 bits of precision, and the third
a string.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-note-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-note-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}]

The keyword \texttt{mutable} is important in the type's definition. If
we leave it out, any objects created with this type will be immutable,
and cannot be changed once they've been created. We will see examples of
this in the main chapters of these lecture notes.

\end{tcolorbox}

Think of a composite type such as this as a \emph{template}. We can use
and reuse the same template to create multiple instances, or
\textbf{objects}, of that template. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{22.5}\NormalTok{, }\StringTok{"middle"}\NormalTok{)}
\NormalTok{bob }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{2}\NormalTok{, }\FloatTok{40.0}\NormalTok{, }\StringTok{"lower"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This will create two \texttt{Speaker} objects and store them in the
variables \texttt{alice} and \texttt{bob}. The first instance has a
grammar of type \texttt{1} (we haven't really specified yet what that
means---but we will in the main chapters of these notes), the second a
grammar of type \texttt{2}. The first has an age of \texttt{22.5} (which
we might interpret as years), the second an age of \texttt{40.0}.
Finally, the first speaker is defined to be middle-class, the second,
lower-class.

\subsection{Functions}\label{functions-1}

The actual functionality of composite objects will be defined by
\textbf{functions}, which manipulate those objects.

For example, suppose we want to implement a function that changes a
speaker's grammar to \texttt{i} (from whichever value it happens to have
at the moment), where \texttt{i} is some integer. This we can achieve
with the following function. The function takes two \textbf{arguments}:
a \texttt{Speaker} object, and \texttt{i}. It then modifies the
speaker's \texttt{grammar} field to read \texttt{i}. (Fields are
accessed using the \texttt{.} notation.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{change\_grammar!}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Speaker}\NormalTok{, i}\OperatorTok{::}\DataTypeTok{Int}\NormalTok{)}
\NormalTok{  x.grammar }\OperatorTok{=}\NormalTok{ i}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Here's a function that increments a speaker's age by one year:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{grow!}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Speaker}\NormalTok{)}
\NormalTok{  x.age }\OperatorTok{=}\NormalTok{ x.age }\OperatorTok{+} \FloatTok{1}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-note-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-note-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}]

By convention, functions which modify things are appended with a
\texttt{!} in their name in Julia. This is not mandatory, but is good
practice, since looking at the function name immediately tells you
whether the function modifies an object or not.

\end{tcolorbox}

Functions do not need to manipulate objects created from composite
types: they can do many other things, too. For example, the following
function takes three integers and returns their sum:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sum3}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Int}\NormalTok{, y}\OperatorTok{::}\DataTypeTok{Int}\NormalTok{, z}\OperatorTok{::}\DataTypeTok{Int}\NormalTok{)}
  \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\OperatorTok{+}\NormalTok{ z}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can then call the function like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{firstnumber }\OperatorTok{=} \FloatTok{4}
\NormalTok{secondnumber }\OperatorTok{=} \FloatTok{3}
\NormalTok{thirdnumber }\OperatorTok{=} \FloatTok{3}
\FunctionTok{sum3}\NormalTok{(firstnumber, secondnumber, thirdnumber)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

Functions need not have return values---indeed, our
\texttt{change\_grammar!} function doesn't have one. Some functions also
have no arguments, like the following function which simply prints the
string \texttt{"Hello,\ world!"} to the screen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sayhello}\NormalTok{()}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Hello, world!"}\NormalTok{)}
\KeywordTok{end}

\FunctionTok{sayhello}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hello, world!
\end{verbatim}

\subsection{Constructors}\label{constructors}

\textbf{Constructors} are special functions used to create objects from
composite types. Recall that, above, we created a speaker like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{22.5}\NormalTok{, }\StringTok{"middle"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

What if we want each speaker to have age 0 when they are created? This
is easy to do with a constructor that supplies this default value. The
constructor will have to have the same name as the composite type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{Speaker}\NormalTok{(grammar}\OperatorTok{::}\DataTypeTok{Int}\NormalTok{, class}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}
  \FunctionTok{Speaker}\NormalTok{(grammar, }\FloatTok{0.0}\NormalTok{, class)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

What this constructor function does is to simply call the default
constructor (which takes three values), supplying \texttt{0.0} as the
new speaker's age.

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-note-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-note-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}]

There is a shorter and possibly more intuitive way of definining this
constructor:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Speaker}\NormalTok{(grammar}\OperatorTok{::}\DataTypeTok{Int}\NormalTok{, class}\OperatorTok{::}\DataTypeTok{String}\NormalTok{) }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(grammar, }\FloatTok{0.0}\NormalTok{, class)}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

Defining a new constructor does not remove the default constructor.
Hence we can ``birth'' a speaker at age 10, for example, if we want to:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{baby }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{1}\NormalTok{, }\StringTok{"middle"}\NormalTok{) }\CommentTok{\# 0 years old}
\NormalTok{child }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{10.0}\NormalTok{, }\StringTok{"middle"}\NormalTok{) }\CommentTok{\# 10 years old}
\end{Highlighting}
\end{Shaded}

\subsection{Control flow}\label{control-flow}

Programs often need to check whether some condition is fulfilled or not,
and continue one way or another depending on that check's outcome. For
example, suppose we want to implement a \texttt{class\_trip} function
that takes a speaker from their social class to the one immediately
higher class. We could write something like the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{classtrip!}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Speaker}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ x.class }\OperatorTok{==} \StringTok{"lower"}
\NormalTok{    x.class }\OperatorTok{=} \StringTok{"middle"}
  \ControlFlowTok{elseif}\NormalTok{ x.class }\OperatorTok{==} \StringTok{"middle"}
\NormalTok{    x.class }\OperatorTok{=} \StringTok{"upper"}
  \ControlFlowTok{elseif}\NormalTok{ x.class }\OperatorTok{==} \StringTok{"upper"}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Cannot take a class trip {-} class already upper!"}\NormalTok{)}
  \ControlFlowTok{else}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Speaker is of unknown class."}\NormalTok{)}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-note-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-note-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}]

Note the very crucial difference between \texttt{==} and \texttt{=}. The
double equals sign is used for comparisons, the single one for
assignments. Confusing these two is a very common source of beginner
errors.

\end{tcolorbox}

\subsection{Loops}\label{loops}

Programs also often need to carry out some action repetitively. For
example, suppose we wish to define a function that takes an array of
numbers of \emph{arbitrary} length and returns the mean of the numbers
in that array. Our function will need to take the sum over the entire
array, then divide by the length of the array. One way of doing this is
by using a \texttt{for} loop. (Note that \texttt{Array\{Float64\}}
specifies that we expect, as input, an array of floating-point numbers,
and that \texttt{length} is a function that returns the number of
elements in an array.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{average}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Array\{Float64\}}\NormalTok{)}
\NormalTok{  S }\OperatorTok{=} \FloatTok{0}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{length}\NormalTok{(x)}
\NormalTok{    S }\OperatorTok{=}\NormalTok{ S }\OperatorTok{+}\NormalTok{ x[i]}
  \ControlFlowTok{end}

  \ControlFlowTok{return}\NormalTok{ S}\OperatorTok{/}\FunctionTok{length}\NormalTok{(x)}
\KeywordTok{end}

\CommentTok{\# try it out}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\FloatTok{20.0}\NormalTok{, }\FloatTok{43.0}\NormalTok{, }\FloatTok{20.3}\NormalTok{, }\FloatTok{30.3}\NormalTok{]}
\FunctionTok{average}\NormalTok{(numbers)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
28.4
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, left=2mm, colbacktitle=quarto-callout-note-color!10!white, titlerule=0mm, breakable, arc=.35mm, opacitybacktitle=0.6, coltitle=black, opacityback=0, toprule=.15mm, bottomrule=.15mm, colframe=quarto-callout-note-color-frame, bottomtitle=1mm, rightrule=.15mm, leftrule=.75mm, colback=white, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}]

This example is a bit silly, since Julia (of course) already has a
ready-made function that takes sums over arrays: \texttt{sum}. But it
serves to illustrate how \texttt{for} loops operate.

\end{tcolorbox}

Another use case for a \texttt{for} loop might be the following. Suppose
we have collected a number of \texttt{Speaker} objects in an array, and
wish to print out the age of each speaker. This is easy to do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{22.5}\NormalTok{, }\StringTok{"middle"}\NormalTok{)}
\NormalTok{bob }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{2}\NormalTok{, }\FloatTok{40.0}\NormalTok{, }\StringTok{"lower"}\NormalTok{)}
\NormalTok{caroline }\OperatorTok{=} \FunctionTok{Speaker}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{80.8}\NormalTok{, }\StringTok{"lower"}\NormalTok{)}

\NormalTok{speakers }\OperatorTok{=}\NormalTok{ [alice, bob, caroline]}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{length}\NormalTok{(speakers)}
  \FunctionTok{println}\NormalTok{(speakers[i].age)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
22.5
40.0
80.8
\end{verbatim}

However, there is an even better (a more ``Julian'', i.e.~more
idiomatic) solution. We first write a function that returns a speaker's
age:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{get\_age}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Speaker}\NormalTok{)}
  \ControlFlowTok{return}\NormalTok{ x.age}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Or using the shorter syntax:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_age}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Speaker}\NormalTok{) }\OperatorTok{=}\NormalTok{ x.age}
\end{Highlighting}
\end{Shaded}

We can then use the \texttt{.} affix to apply this function to each
speaker in our array:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get\_age}\NormalTok{.(speakers)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3-element Vector{Float64}:
 22.5
 40.0
 80.8
\end{verbatim}

This returns a three-element vector containing the speakers' ages, but
does not print it to the terminal. If we want the latter too, we just
call \texttt{println}, broadcast over the array:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{.(}\FunctionTok{get\_age}\NormalTok{.(speakers))}
\end{Highlighting}
\end{Shaded}

\subsection{Array comprehensions}\label{array-comprehensions-3}

Another powerful feature of the Julia language are \textbf{array
comprehensions}. An array comprehension is used to create an array by
repeatedly executing a desired expression. For example, suppose we want
to generate an array that consists of the squares of the first 100
natural numbers, including zero (so the array needs to contain
\(0^2 = 0\), \(1^2 = 1\), \(2^2 = 4\) and so on).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[i}\OperatorTok{\^{}}\FloatTok{2}\NormalTok{ for i }\KeywordTok{in} \FloatTok{0}\OperatorTok{:}\FloatTok{99}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
100-element Vector{Int64}:
    0
    1
    4
    9
   16
   25
   36
   49
   64
   81
  100
  121
  144
    â‹®
 7744
 7921
 8100
 8281
 8464
 8649
 8836
 9025
 9216
 9409
 9604
 9801
\end{verbatim}

The expression to be evaluated in an array comprehension can be
arbitrarily complex; for example, it can be a function. Suppose we
wanted (for whatever reason) to create an array that repeats the age of
our speaker \texttt{alice} fifty times. We could accomplish this with
the following array comprehension:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\FunctionTok{get\_age}\NormalTok{(alice) for i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FloatTok{50}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
50-element Vector{Float64}:
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
  â‹®
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
 22.5
\end{verbatim}

You will find more useful applications of array comprehensions in the
main chapters; they are often the most elegant way of creating
trajectories over entire populations of speakers, for example.

\subsection{Preparing for the future}\label{preparing-for-the-future}

Go ahead and install the following packages, which we will rely on
later. \emph{Plots} is used to draw figures, and \emph{Agents} gives
some useful functionality for agent-based models.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{Pkg}\NormalTok{.}\FunctionTok{add}\NormalTok{(}\StringTok{"Plots"}\NormalTok{)}
\BuiltInTok{Pkg}\NormalTok{.}\FunctionTok{add}\NormalTok{(}\StringTok{"Agents"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}




\end{document}
