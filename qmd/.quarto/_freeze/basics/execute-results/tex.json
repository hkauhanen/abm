{
  "hash": "9410689b401ce291ae02ad67d183d2c1",
  "result": {
    "markdown": "---\ntitle: \"2. Programming basics\"\n---\n\n## Getting started with Julia\n\nProgramming languages come in many forms and flavours. Some (such as C) produce code that is quick to run but difficult to write; others (such as Python and R) do much the opposite. **Julia** is a fairly recent language that tries to combine the best of both worlds: it tries to give you both speed and a convenient syntax. Julia is extremely well suited for simulation work, and this is the reason we will be using it in this course.\n\nTo get started, visit [https://julialang.org/](https://julialang.org/) to download and install Julia on your system. Make sure to download **version 1.9.3** or newer. See [here](https://julialang.org/downloads/platform/) for platform-specific installation instructions.\n\n::: {.callout-note}\nIf you already speak another programming language, it is useful to refer to [this document](https://docs.julialang.org/en/v1/manual/noteworthy-differences/) that details some noteworthy differences between Julia and common languages such as R, Python and C.\n:::\n\nNext, launch Julia. How this is done depends on your operating system---you may find the program in a \"Start\" menu or similar, or you may have to launch it from the command line by typing `julia`.\n\nHaving successfully launched Julia, you should see a screen like the one depicted in @fig-julia-REPL. \n\n![The Julia REPL.](img/julia_REPL.png){#fig-julia-REPL}\n\nThis is called the Julia REPL (which stands for the *read-eval-print-loop*). Here you can type in commands and Julia will execute them for you. For example, try the following, which will simply add together the two numbers 2 and 3 and return the result:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2+3\n```\n\n::: {.cell-output .cell-output-display execution_count=101}\n```\n5\n```\n:::\n:::\n\n\nOr you can store a couple of strings in variables and print them:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nfirstname = \"John\"\nlastname = \"Doe\"\nprintln(\"My full name is $firstname $lastname.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy full name is John Doe.\n```\n:::\n:::\n\n\nIn principle, it is possible to do all your Julia programming using the REPL and external files, so-called **scripts**. Often, however, it is useful to carry out program development in a dedicated **programming environment** (also sometimes known as IDEs, for \"integrated development environment\"). In Julia, one such environment is called *Pluto*. We will now install Pluto and launch it.\n\n**Packages** are additional program libraries that extend the capabilities of the base system. In Julia, they are easy to install using a package manager, which is called *Pkg*. To use Pkg, we first need to tell Julia that we want to use it:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing Pkg\n```\n:::\n\n\nNext, we use the `Pkg.add` function to install Pluto:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nPkg.add(\"Pluto\")\n```\n:::\n\n\nYou can use this same logic to install whichever Julia package you may happen to need. Available packages are listed at [https://juliapackages.com/](https://juliapackages.com/).\n\n::: {.callout-note}\nInstalling a package may take a while; this is often because packages have interrelationships---dependencies---between them. When you ask Julia to install Pluto, for example, Pkg will install for you all packages that Pluto depends on but that might not already be present on your system. Wait patiently for the installation to finish.\n:::\n\nHaving successfully installed Pluto, we instruct Julia that we want to use it, and call the `Pluto.run()` function. This will start Pluto in a browser window.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nusing Pluto\nPluto.run()\n```\n:::\n\n\nYou should see something like the screen in @fig-Pluto.\n\n\nClick on *Create a new notebook*. A notebook will open up, and you will be able type in code in a so-called code **cell**. Try typing up our little addition example from above:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n2+3\n```\n:::\n\n\nUnlike in the REPL, where pressing Enter executes the code, in a Pluto notebook cell Enter makes a new line. Use the combination Shift+Enter to execute the code instead. This will display the result above the code cell.\n\nNext, create another cell by clicking on the small plus (+) sign. Type in our second example and try executing it with Shift+Enter:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfirstname = \"John\"\nlastname = \"Doe\"\nprintln(\"My full name is $firstname $lastname.\")\n```\n:::\n\n\nPluto will throw an error! Why is this? Essentially, we are dealing with a design choice made by the Pluto developers, which requires multi-expression cells to be surrounded in a `begin ... end` block. Fortunately, this is very easy to do. Simply click on \"Wrap all code in a *begin ... end* block\", or add the `begin` and `end` keywords manually:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nbegin\n  firstname = \"John\"\n  lastname = \"Doe\"\n  println(\"My full name is $firstname $lastname.\")\nend\n```\n:::\n\n\nAnd voil√†---we have all we need!\n\n\nThe following sections will consist of a *very* brief introduction to some key aspects of Julia that we will need to conduct our model simulations. Naturally, this introduction is nowhere near comprehensive. For full details, refer to the official [Julia Documentation](https://docs.julialang.org/).\n\n\n## Fundamental types\n\nMost programming languages make available a number of different **types** of data. Fundamental types in many modern programming languages include integers (used to represent integers), floating-point numbers (used to represent real numbers), Booleans (used to represent truth values), strings (character sequences), various types of arrays (used to represent tuples, vectors, matrices etc.), as well as lists (collections of objects).\n\nWe have already seen integers and strings. These can be stored in **variables**. For instance, above we stored the strings `\"John\"` and `\"Doe\"` in the variables `firstname` and `lastname`. Think of variables as \"boxes\" that hold data. The contents of these boxes can be changed. For example, we reuse the `firstname` variable if we want to change our name:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfirstname = \"Jane\"\n```\n:::\n\n\nNow the variable `firstname` will hold the string `\"Jane\"` instead of the string `\"John\"`.\n\nWe can even do something like the following, whereby the variable's type changes from string to integer:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfirstname = 2\n```\n:::\n\n\n::: {.callout-note}\nIn Pluto, if a variable is changed in one code cell, then its value also changes in all other cells that make use of the same variable.\n:::\n\nSo-called **floating-point numbers**, which represent real numbers up to some precision which is determined by both the programming language and the computer's architecture, are easy to create: just make sure that there is a decimal point in the number:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nsmallnumber = 2.5\nevensmallernumber = 2.0\nlargenumber = 49812093.30\n```\n:::\n\n\nMost mathematical operations are self-explanatory:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nsmallnumber = 2.5 + 4.0 # equals 6.5\nanothernumber = evensmallernumber * 2 # equals 4.0\ndivided = anothernumber/4.0 # equals 1.0\n```\n:::\n\n\n::: {.callout-note}\nAnything written after a hash sign (`#`) on a line in Julia constitutes a **comment**. Comments are not executed by the compiler; it does not \"see\" them. They can (and should!) be used to add explanations to source code that aid the programmer or someone else who might read the code later. For example, when defining custom types or functions (see below), it is good practice to add some lines of comments before the type or function definition, explaining what the type contains or what the function does, what the arguments to the function are, and what (if anything) the function returns.\n:::\n\n\n## Arrays and broadcasting\n\nTo represent a tuple (or vector) of numbers, we can make an **array**:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nmanynumbers = [1, 4, 6, 2, 20]\n```\n:::\n\n\nThe contents of an array can be fetched one by one, if necessary, or subsetted:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nmanynumbers[2] # equals 4\nmanynumbers[2:3] # equals [4, 6]\n```\n:::\n\n\nThe special keyword `end` fetches the last item in an array:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nmanynumbers[end] # equals 20\n```\n:::\n\n\nOperations and functions (we'll talk about functions below) in Julia can be **broadcast**, meaning that they are applied elementwise to all elements in an array. To take a simple example, suppose we want to add 1 to each element in our array of integers, `manynumbers`. The following won't do, because we'd be trying to add a scalar to a vector, something that isn't mathematically defined:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nmanynumbers + 1 # will throw an error\n```\n:::\n\n\nThe following *will* work, but is cumbersome to write:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nmanynumbers + [1, 1, 1, 1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=110}\n```\n5-element Vector{Int64}:\n  2\n  5\n  7\n  3\n 21\n```\n:::\n:::\n\n\nInstead of this, we can use the special `.` prefix to apply the sum operation elementwise:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nmanynumbers .+ 1\n```\n\n::: {.cell-output .cell-output-display execution_count=111}\n```\n5-element Vector{Int64}:\n  2\n  5\n  7\n  3\n 21\n```\n:::\n:::\n\n\nNote how the output is exactly the same.\n\n\n## Custom types\n\nSometimes basic types aren't quite enough. For example, suppose we want to simulate the behaviour of a speaker--listener, i.e. an agent that has some representation of language and can interact with other agents. Is it an integer? A floating-point number? A string? It isn't really any of these. What we want to do is to be able to define our own data structure, our own type.\n\nFor example, suppose that we can represent a speaker's grammar as an integer (on the assumption that we index all grammars with the natural numbers). Suppose, moreover, that we are interested in a speaker's age as well as its social class. Then we might want a data type such as the following, called a **composite type** in Julia:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nmutable struct Speaker\n  grammar::Int\n  age::Float64\n  class::String\nend\n```\n:::\n\n\nIn this definition, we introduce a composite type consisting of three primitive type inside it: a `grammar`, an `age`, and a (social) `class`. The first is declared to be an integer, the second a floating-point number with 64 bits of precision, and the third a string.\n\n::: {.callout-note}\nThe keyword `mutable` is important in the type's definition. If we leave it out, any objects created with this type will be immutable, and cannot be changed once they've been created. We will see examples of this in the main chapters of these lecture notes.\n:::\n\nThink of a composite type such as this as a *template*. We can use and reuse the same template to create multiple instances, or **objects**, of that template. For example:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nalice = Speaker(1, 22.5, \"middle\")\nbob = Speaker(2, 40.0, \"lower\")\n```\n:::\n\n\nThis will create two `Speaker` objects and store them in the variables `alice` and `bob`. The first instance has a grammar of type `1` (we haven't really specified yet what that means---but we will in the main chapters of these notes), the second a grammar of type `2`. The first has an age of `22.5` (which we might interpret as years), the second an age of `40.0`. Finally, the first speaker is defined to be middle-class, the second, lower-class.\n\n\n## Functions\n\nThe actual functionality of composite objects will be defined by **functions**, which manipulate those objects.\n\nFor example, suppose we want to implement a function that changes a speaker's grammar to `i` (from whichever value it happens to have at the moment), where `i` is some integer. This we can achieve with the following function. The function takes two **arguments**: a `Speaker` object, and `i`. It then modifies the speaker's `grammar` field to read `i`. (Fields are accessed using the `.` notation.)\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nfunction change_grammar!(x::Speaker, i::Int)\n  x.grammar = i\nend\n```\n:::\n\n\nHere's a function that increments a speaker's age by one year:\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nfunction grow!(x::Speaker)\n  x.age = x.age + 1\nend\n```\n:::\n\n\n::: {.callout-note}\nBy convention, functions which modify things are appended with a `!` in their name in Julia. This is not mandatory, but is good practice, since looking at the function name immediately tells you whether the function modifies an object or not.\n:::\n\nFunctions do not need to manipulate objects created from composite types: they can do many other things, too. For example, the following function takes three integers and returns their sum:\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nfunction sum3(x::Int, y::Int, z::Int)\n  return x + y + z\nend\n```\n:::\n\n\nWe can then call the function like this:\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nfirstnumber = 4\nsecondnumber = 3\nthirdnumber = 3\nsum3(firstnumber, secondnumber, thirdnumber)\n```\n\n::: {.cell-output .cell-output-display execution_count=117}\n```\n10\n```\n:::\n:::\n\n\nFunctions need not have return values---indeed, our `change_grammar!` function doesn't have one. Some functions also have no arguments, like the following function which simply prints the string `\"Hello, world!\"` to the screen:\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nfunction sayhello()\n  println(\"Hello, world!\")\nend\n\nsayhello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, world!\n```\n:::\n:::\n\n\n## Constructors\n\n**Constructors** are special functions used to create objects from composite types. Recall that, above, we created a speaker like this:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nalice = Speaker(1, 22.5, \"middle\")\n```\n:::\n\n\nWhat if we want each speaker to have age 0 when they are created? This is easy to do with a constructor that supplies this default value. The constructor will have to have the same name as the composite type.\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\nfunction Speaker(grammar::Int, class::String)\n  Speaker(grammar, 0.0, class)\nend\n```\n:::\n\n\nWhat this constructor function does is to simply call the default constructor (which takes three values), supplying `0.0` as the new speaker's age.\n\n::: {.callout-note}\nThere is a shorter and possibly more intuitive way of definining this constructor:\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\nSpeaker(grammar::Int, class::String) = Speaker(grammar, 0.0, class)\n```\n:::\n\n\n:::\n\nDefining a new constructor does not remove the default constructor. Hence we can \"birth\" a speaker at age 10, for example, if we want to:\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nbaby = Speaker(1, \"middle\") # 0 years old\nchild = Speaker(1, 10.0, \"middle\") # 10 years old\n```\n:::\n\n\n## Control flow\n\nPrograms often need to check whether some condition is fulfilled or not, and continue one way or another depending on that check's outcome. For example, suppose we want to implement a `class_trip` function that takes a speaker from their social class to the one immediately higher class. We could write something like the following:\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nfunction classtrip!(x::Speaker)\n  if x.class == \"lower\"\n    x.class = \"middle\"\n  elseif x.class == \"middle\"\n    x.class = \"upper\"\n  elseif x.class == \"upper\"\n    println(\"Cannot take a class trip - class already upper!\")\n  else\n    println(\"Speaker is of unknown class.\")\n  end\nend\n```\n:::\n\n\n::: {.callout-note}\nNote the very crucial difference between `==` and `=`. The double equals sign is used for comparisons, the single one for assignments. Confusing these two is a very common source of beginner errors.\n:::\n\n\n## Loops\n\nPrograms also often need to carry out some action repetitively. For example, suppose we wish to define a function that takes an array of numbers of *arbitrary* length and returns the mean of the numbers in that array. Our function will need to take the sum over the entire array, then divide by the length of the array. One way of doing this is by using a `for` loop. (Note that `Array{Float64}` specifies that we expect, as input, an array of floating-point numbers, and that `length` is a function that returns the number of elements in an array.)\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\nfunction average(x::Array{Float64})\n  S = 0\n\n  for i in 1:length(x)\n    S = S + x[i]\n  end\n\n  return S/length(x)\nend\n\n# try it out\nnumbers = [20.0, 43.0, 20.3, 30.3]\naverage(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=124}\n```\n28.4\n```\n:::\n:::\n\n\n::: {.callout-note}\nThis example is a bit silly, since Julia (of course) already has a ready-made function that takes sums over arrays: `sum`. But it serves to illustrate how `for` loops operate.\n:::\n\nAnother use case for a `for` loop might be the following. Suppose we have collected a number of `Speaker` objects in an array, and wish to print out the age of each speaker. This is easy to do:\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\nalice = Speaker(1, 22.5, \"middle\")\nbob = Speaker(2, 40.0, \"lower\")\ncaroline = Speaker(1, 80.8, \"lower\")\n\nspeakers = [alice, bob, caroline]\n\nfor i in 1:length(speakers)\n  println(speakers[i].age)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n22.5\n40.0\n80.8\n```\n:::\n:::\n\n\nHowever, there is an even better (a more \"Julian\", i.e. more idiomatic) solution. We first write a function that returns a speaker's age:\n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\nfunction get_age(x::Speaker)\n  return x.age\nend\n```\n:::\n\n\nOr using the shorter syntax:\n\n::: {.cell execution_count=34}\n``` {.julia .cell-code}\nget_age(x::Speaker) = x.age\n```\n:::\n\n\nWe can then use the `.` affix to apply this function to each speaker in our array:\n\n::: {.cell execution_count=35}\n``` {.julia .cell-code}\nget_age.(speakers)\n```\n\n::: {.cell-output .cell-output-display execution_count=128}\n```\n3-element Vector{Float64}:\n 22.5\n 40.0\n 80.8\n```\n:::\n:::\n\n\nThis returns a three-element vector containing the speakers' ages, but does not print it to the terminal. If we want the latter too, we just call `println`, broadcast over the array:\n\n::: {.cell execution_count=36}\n``` {.julia .cell-code}\nprintln.(get_age.(speakers))\n```\n:::\n\n\n## Array comprehensions\n\nAnother powerful feature of the Julia language are **array comprehensions**. An array comprehension is used to create an array by repeatedly executing a desired expression. For example, suppose we want to generate an array that consists of the squares of the first 100 natural numbers, including zero (so the array needs to contain $0^2 = 0$, $1^2 = 1$, $2^2 = 4$ and so on).\n\n::: {.cell execution_count=37}\n``` {.julia .cell-code}\n[i^2 for i in 0:99]\n```\n\n::: {.cell-output .cell-output-display execution_count=130}\n```\n100-element Vector{Int64}:\n    0\n    1\n    4\n    9\n   16\n   25\n   36\n   49\n   64\n   81\n  100\n  121\n  144\n    ‚ãÆ\n 7744\n 7921\n 8100\n 8281\n 8464\n 8649\n 8836\n 9025\n 9216\n 9409\n 9604\n 9801\n```\n:::\n:::\n\n\nThe expression to be evaluated in an array comprehension can be arbitrarily complex; for example, it can be a function. Suppose we wanted (for whatever reason) to create an array that repeats the age of our speaker `alice` fifty times. We could accomplish this with the following array comprehension:\n\n::: {.cell execution_count=38}\n``` {.julia .cell-code}\n[get_age(alice) for i in 1:50]\n```\n\n::: {.cell-output .cell-output-display execution_count=131}\n```\n50-element Vector{Float64}:\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n  ‚ãÆ\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n```\n:::\n:::\n\n\nYou will find more useful applications of array comprehensions in the main chapters; they are often the most elegant way of creating trajectories over entire populations of speakers, for example.\n\n\n## Preparing for the future\n\nGo ahead and install the following packages, which we will rely on later. *Plots* is used to draw figures, and *Agents* gives some useful functionality for agent-based models.\n\n::: {.cell execution_count=39}\n``` {.julia .cell-code}\nPkg.add(\"Plots\")\nPkg.add(\"Agents\")\n```\n:::\n\n\n",
    "supporting": [
      "basics_files/figure-pdf"
    ],
    "filters": []
  }
}