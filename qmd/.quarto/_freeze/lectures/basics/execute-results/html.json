{
  "hash": "6eb08d9050523a014f2760625c887b80",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Programming basics\"\ndate: 04/16/2024\ncategories:\n  - lecture\nformat:\n  revealjs:\n    output-file: basics-slides.html\n---\n\n## TUDÚ\n\n- comments\n- packages\n- functions vs methods (multiple dispatch)\n- meaning of dynamic typing\n- custom types\n- broadcasting of functions\n- array comprehensions\n- explicit type declarations for custom types and function arguments\n- conditionals\n- loops\n\n\n## Variables and assignments\n\n- In programming, a **variable** is a \"storage box\" that stores data for later use\n- The data is **assigned** to the variable using the `=` operator\n- Here, we assign the number 5 to a variable named `my_number`:\n\n::: {#f1e3f6c2 .cell execution_count=1}\n``` {.julia .cell-code}\nmy_number = 5\n```\n:::\n\n\n- We can now do things such as:\n\n::: {#3518e77d .cell execution_count=2}\n``` {.julia .cell-code}\nmy_number + my_number\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n10\n```\n:::\n:::\n\n\n## Fundamental types\n\n- Variables can store different **types** of data:\n  - Integers: `1`, `2`, `-100`, ...\n  - Floating-point numbers (\"floats\"): `3.14`, `pi`, `1.0`, ...\n  - Booleans: `true`, `false`\n  - Strings: `\"John\"`, `\"Mary\"`\n  - Arrays: `[1, 2, 3, 4]`, `[1 2 3 4]`\n  - And some others... we'll meet them later\n\n\n## Arithmetic operations\n\n- Arithmetic operations are mostly self-explanatory. For example:\n\n::: {#2b01c1d0 .cell execution_count=3}\n``` {.julia .cell-code}\nnumber1 = 15\nnumber2 = 20\nnumber3 = 10*(number1 + number2) - number1/number2\nnumber3\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n349.25\n```\n:::\n:::\n\n\n## String concatenation\n\n- Julia overloads the `*` operator for strings too:\n\n::: {#8ce720e4 .cell execution_count=4}\n``` {.julia .cell-code}\nstring1 = \"This \"\nstring2 = \"is a\"\nstring3 = \" sentence\"\nstring1 * string2 * string3 * \"!\"\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n\"This is a sentence!\"\n```\n:::\n:::\n\n\n## Arrays\n\n- An array is a (possibly multidimensional) collection of objects\n  - A one-dimensional array is a vector, a two-dimensional array is a matrix, and so on\n- Usually we work with arrays of numbers. They are easy to create:\n\n::: {#dc4b52b6 .cell execution_count=5}\n``` {.julia .cell-code}\nmy_array = [10, 20, 30, 40]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n4-element Vector{Int64}:\n 10\n 20\n 30\n 40\n```\n:::\n:::\n\n\n## Accessing array contents\n\n- The elements of an array can be accessed one-by-one by referencing their location or **index** in the array:\n\n::: {#c0f1e70c .cell execution_count=6}\n``` {.julia .cell-code}\nmy_array = [10, 20, 30, 40]\nmy_array[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n10\n```\n:::\n:::\n\n\nor\n\n::: {#ec5e3bda .cell execution_count=7}\n``` {.julia .cell-code}\nmy_array[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n20\n```\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Accessing array contents\n:::\n\n- The special keyword `end` fetches the last element:\n\n::: {#fde6781a .cell execution_count=8}\n``` {.julia .cell-code}\nmy_array[end]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n40\n```\n:::\n:::\n\n\n- Arrays can also be subsetted:\n\n::: {#3f3f28a5 .cell execution_count=9}\n``` {.julia .cell-code}\nmy_array[2:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n2-element Vector{Int64}:\n 20\n 30\n```\n:::\n:::\n\n\n## Broadcasting\n\n- Suppose I want to add `1` to each number in `my_array`\n- The following will **not** work:\n\n::: {#0669658a .cell execution_count=10}\n``` {.julia .cell-code}\nmy_array + 1\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching +(::Vector{Int64}, ::Int64)\nFor element-wise addition, use broadcasting with dot syntax: array .+ scalar\n\nClosest candidates are:\n  +(::Any, ::Any, <span class=\"ansi-bright-red-fg\">::Any</span>, <span class=\"ansi-bright-red-fg\">::Any...</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">operators.jl:587</span>\n  +(<span class=\"ansi-bright-red-fg\">::Missing</span>, ::Number)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">missing.jl:123</span>\n  +(<span class=\"ansi-bright-red-fg\">::P</span>, ::S) where {S&lt;:Number, T, X, P&lt;:Polynomials.FactoredPolynomial{T, X}}\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Polynomials</span> <span class=\"ansi-bright-black-fg\">~/.julia/packages/Polynomials/5ZhzG/src/polynomials/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">factored_polynomial.jl:257</span>\n  ...\n</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Broadcasting\n:::\n\n- Why? Because mathematically the operation \"add a scalar into a vector\" is undefined\n- To apply an operator **elementwise** to each element in an array, we can prefix the operator with a period. In Julia-speak, this is called **broadcasting**.\n\n::: {#da5f2bd8 .cell execution_count=11}\n``` {.julia .cell-code}\nmy_array .+ 1\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n4-element Vector{Int64}:\n 11\n 21\n 31\n 41\n```\n:::\n:::\n\n\n## Type mismatch\n\n- Why does the following not work?\n\n::: {#58b5bef6 .cell execution_count=12}\n``` {.julia .cell-code}\nmy_string = \"My shoe size is: \"\nmy_number = 41\nmy_string * my_number\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching *(::String, ::Int64)\n\nClosest candidates are:\n  *(::Any, ::Any, <span class=\"ansi-bright-red-fg\">::Any</span>, <span class=\"ansi-bright-red-fg\">::Any...</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">operators.jl:587</span>\n  *(<span class=\"ansi-bright-red-fg\">::Missing</span>, ::Number)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">missing.jl:123</span>\n  *(<span class=\"ansi-bright-red-fg\">::Polynomials.AbstractPolynomial</span>, ::Union{Number, Matrix})\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Polynomials</span> <span class=\"ansi-bright-black-fg\">~/.julia/packages/Polynomials/5ZhzG/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">common.jl:1041</span>\n  ...\n</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Type conversion\n:::\n\n- To make it work, we need to explicitly **convert** the integer into a string:\n\n::: {#8eda3d91 .cell execution_count=13}\n``` {.julia .cell-code}\nmy_string * string(my_number)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n\"My shoe size is: 41\"\n```\n:::\n:::\n\n\n## Functions\n\n- A **function**, sometimes also known as a **subroutine**, is a **reusable** piece of code that performs, well, some function...\n- We define it once and then can use it as many times as we like\n- A function can (but need not) take inputs -- these are known as the function's **arguments**\n- A function can (but need not) give an output -- this is known as the function's **return value**\n\n\n## Functions: example\n\n- Here is a function that takes two arguments, an array and a scalar number, and adds the scalar to each element of the array\n- I'm calling the function `add_elementwise`\n\n::: {#c83738b3 .cell execution_count=14}\n``` {.julia .cell-code}\nfunction add_elementwise(array, scalar)\n  result = array .+ scalar\n  return result\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nadd_elementwise (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Functions: example\n:::\n\n- We can now **call** the function on particular arrays and numbers:\n\n::: {#1c253fa5 .cell execution_count=15}\n``` {.julia .cell-code}\nmy_array = [10, 20, 30, 40]\nadd_elementwise(my_array, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n4-element Vector{Int64}:\n 11\n 21\n 31\n 41\n```\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Functions: example\n:::\n\n::: {#053f4b27 .cell execution_count=16}\n``` {.julia .cell-code}\nadd_elementwise(my_array, -23.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n4-element Vector{Float64}:\n -13.5\n  -3.5\n   6.5\n  16.5\n```\n:::\n:::\n\n\n## Exercise {.ex-slide}\n\nWrite a function with the following properties:\n\n- The function's name is `announce_age`\n- The function takes two arguments, the first a person's name, the second a number that is that person's age\n- The function's return value is a string which announces the person's age in this format: `\"John is 40 years old\"`\n\n::: {.content-visible when-format=\"revealjs\"}\n## Exercise {.ex-slide}\n:::\n\n::: {.callout-tip collapse=true title=\"Answer\"}\nHere is the function definition:\n\n::: {#57db9ba7 .cell execution_count=17}\n``` {.julia .cell-code}\nfunction announce_age(name, age)\n  return name * \" is \" * string(age) * \" years old\"\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nannounce_age (generic function with 1 method)\n```\n:::\n:::\n\n\nLet's test it:\n\n::: {#e2531e6f .cell execution_count=18}\n``` {.julia .cell-code}\nannounce_age(\"John\", 40)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n\"John is 40 years old\"\n```\n:::\n:::\n\n\n:::\n\n\n## Custom types (\"classes\" and \"objects\")\n\n- Idea of **object-oriented programming** (OOP): we can make custom types (**classes**) which are instantiated as **objects**\n  - Programming ABMs in a language that does not support this would be very cumbersome\n- In Julia, custom types are defined by way of a special keyword, `struct`\n- A custom type is effectively a combination of variables called the type's **fields**\n- If the fields need to be modifiable later in the program, we use `mutable struct` instead of `struct`\n\n\n## Custom types: example\n\n- Suppose we want to represent a person by way of their name, their age and their shoe size\n- Since these fields (at least age) need to be modifiable, we use a `mutable struct`:\n\n::: {#7fb4f20d .cell execution_count=19}\n``` {.julia .cell-code}\nmutable struct Person\n  name::String\n  age::Int\n  shoesize::Float64\nend\n```\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Custom types: example\n\n::: {#e8a8ec02 .cell execution_count=20}\n``` {.julia .cell-code}\nmutable struct Person\n  name::String\n  age::Int\n  shoesize::Float64\nend\n```\n:::\n\n\n:::\n\n- Here,\n  - `name::String` means the field called `name` is of type string, etc.\n  - `Int` is an integer\n  - in `Float64`, the number specifies the precision of the floating-point number (related to how many decimals it can store)\n\n::: {.content-visible when-format=\"revealjs\"}\n## Custom types: example\n:::\n\n- We can now **construct** an instance of the `Person` custom type, a `Person` object, and store it in a variable:\n\n::: {#eb65ebe9 .cell execution_count=21}\n``` {.julia .cell-code}\njane = Person(\"Jane\", 35, 39.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nPerson(\"Jane\", 35, 39.5)\n```\n:::\n:::\n\n\n- To **access** the fields of an object, we use the following dot syntax:\n\n::: {#b491eed9 .cell execution_count=22}\n``` {.julia .cell-code}\njane.name\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n\"Jane\"\n```\n:::\n:::\n\n\n## Exercise {.ex-slide}\n\nWrite three functions:\n\n1. A function that takes a `Person` object as argument and returns their shoe size\n1. A function that takes a `Person` object and a string as argument, and sets the person's name to be the string supplied as argument\n1. A function that increments a `Person` object's age by one\n \n::: {.content-visible when-format=\"revealjs\"}\n## Exercise {.ex-slide}\n:::\n\n::: {.callout-tip collapse=true title=\"Answer\"}\n\n::: {#8bbb2ae3 .cell execution_count=23}\n``` {.julia .cell-code}\nfunction get_shoesize(x)\n  return x.shoesize\nend\n\nfunction set_name(x, y)\n  x.name = y\nend\n\nfunction become_older(x)\n  x.age = x.age + 1\nend\n```\n:::\n\n\n:::\n\n\n## Explicit type specifications\n\nNote that it is possible (and often good practice) to explicitly set the types of function arguments:\n\n::: {#513a34ce .cell execution_count=24}\n``` {.julia .cell-code}\nfunction get_shoesize(x::Person)\n  return x.shoesize\nend\n\nfunction set_name(x::Person, y::String)\n  x.name = y\nend\n\nfunction become_older(x::Person)\n  x.age = x.age + 1\nend\n```\n:::\n\n\n## Getters and setters\n\n- Functions that return an object's field are sometimes known as **getters**. Functions that set a field are known as **setters**.\n- In Julia, it is customary to append an exclamation point to the name of every setter function. This is to warn users of the function that the function modifies something in the object.\n- Thus, we would rather write:\n\n::: {#739b6dc9 .cell execution_count=25}\n``` {.julia .cell-code}\nfunction set_name!(x::Person, y::String)\n  x.name = y\nend\n```\n:::\n\n\n## Array comprehensions\n\n- What if we wanted to create 3 `Person`s? Easy:\n\n::: {#42fa6624 .cell execution_count=26}\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nPerson(\"Bob\", 65, 42.33)\n```\n:::\n:::\n\n\n- What if we wanted to create 1000 `Person`s?\n\n::: {.content-visible when-format=\"revealjs\"}\n## Array comprehensions\n:::\n\n- Here we can use a powerful feature known as an **array comprehension**. The following creates 1000 persons, each with the same default fields (we'll later see how to modify this), and places them in an array. The array is returned and stored in the `population` variable:\n\n::: {#a45a60b7 .cell execution_count=27}\n``` {.julia .cell-code}\npopulation = [Person(\"M. Musterperson\", 0, 0.0) for i in 1:1000]\n```\n:::\n\n\n- The `i` variable is a dummy variable that only exists for the duration of the array comprehension.\n\n::: {.content-visible when-format=\"revealjs\"}\n## Array comprehensions\n:::\n\n- We can now access individual persons by indexing them from the array:\n\n::: {#d250fc69 .cell execution_count=28}\n``` {.julia .cell-code}\npopulation[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nPerson(\"M. Musterperson\", 0, 0.0)\n```\n:::\n:::\n\n\n- We can also access their fields:\n\n::: {#86fff054 .cell execution_count=29}\n``` {.julia .cell-code}\npopulation[1].name\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n\"M. Musterperson\"\n```\n:::\n:::\n\n\n- And we can set them:\n\n::: {#faf3ce45 .cell execution_count=30}\n``` {.julia .cell-code}\nset_name(population[1], \"Bob the Builder\")\npopulation[1].name\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n\"Bob the Builder\"\n```\n:::\n:::\n\n\n## Random numbers\n\n- To get a (pseudo)random number from between 0 and 1, simply call:\n\n::: {#a0367dd3 .cell execution_count=31}\n``` {.julia .cell-code}\nrand()\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n0.795012825129003\n```\n:::\n:::\n\n\n## Exercise {.ex-slide}\n\nHow can you obtain a random number from between 0 and 50?\n\nHow about between 50 and 100?\n\n::: {.content-visible when-format=\"revealjs\"}\n## Exercise {.ex-slide}\n:::\n\n::: {.callout-tip collapse=true title=\"Answer\"}\nRandom number from between 0 and 50:\n\n::: {#884e1e44 .cell execution_count=32}\n``` {.julia .cell-code}\n50*rand()\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n11.696687353151724\n```\n:::\n:::\n\n\nRandom number from between 50 and 100:\n\n::: {#6f3cb0c6 .cell execution_count=33}\n``` {.julia .cell-code}\n50 + 50*rand()\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n51.24486651050538\n```\n:::\n:::\n\n\n:::\n\n\n## FIXME\n\ncontrol flow -- conditionals and loops?\n\nor is this too much infooos for one session?\n\n\n## Comments\n\n- To improve code readability, we insert comments (these are ignored by the compiler)\n- Single-line comment:\n\n::: {#4d7b30fc .cell execution_count=34}\n``` {.julia .cell-code}\n# the following variable stores my shoe size\nshoesize = 41.5\n```\n:::\n\n\n- Multi-line comment:\n\n::: {#533239bc .cell execution_count=35}\n``` {.julia .cell-code}\n#=\nThe following variable\nstores my shoe size\n=#\nshoesize = 41.5\n```\n:::\n\n\n## Packages\n\n- Basic Julia functionality is extended by **packages**\n- These are installed through a package manager called **Pkg**\n- E.g. to install the *Agents* package (and all its dependencies), we issue these commands:\n\n::: {#d4f5276e .cell execution_count=36}\n``` {.julia .cell-code}\nusing Pkg\nPkg.add(\"Agents\")\n```\n:::\n\n\n- Once the package has been installed, we can load it by:\n\n::: {#e339d316 .cell execution_count=37}\n``` {.julia .cell-code}\nusing Agents\n```\n:::\n\n\n## Homework\n\nFIXME\n\n\n\n## OLD\n\n## Arrays and broadcasting\n\nTo represent a tuple (or vector) of numbers, we can make an **array**:\n\n\n\nThe contents of an array can be fetched one by one, if necessary, or subsetted:\n\n\n\nThe special keyword `end` fetches the last item in an array:\n\n\n\nOperations and functions (we'll talk about functions below) in Julia can be **broadcast**, meaning that they are applied elementwise to all elements in an array. To take a simple example, suppose we want to add 1 to each element in our array of integers, `manynumbers`. The following won't do, because we'd be trying to add a scalar to a vector, something that isn't mathematically defined:\n\n\n\nThe following *will* work, but is cumbersome to write:\n\n::: {#29b950bf .cell execution_count=42}\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n5-element Vector{Int64}:\n  2\n  5\n  7\n  3\n 21\n```\n:::\n:::\n\n\nInstead of this, we can use the special `.` prefix to apply the sum operation elementwise:\n\n::: {#4bada3e0 .cell execution_count=43}\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n5-element Vector{Int64}:\n  2\n  5\n  7\n  3\n 21\n```\n:::\n:::\n\n\nNote how the output is exactly the same.\n\n\n## Custom types\n\nSometimes basic types aren't quite enough. For example, suppose we want to simulate the behaviour of a speaker--listener, i.e. an agent that has some representation of language and can interact with other agents. Is it an integer? A floating-point number? A string? It isn't really any of these. What we want to do is to be able to define our own data structure, our own type.\n\nFor example, suppose that we can represent a speaker's grammar as an integer (on the assumption that we index all grammars with the natural numbers). Suppose, moreover, that we are interested in a speaker's age as well as its social class. Then we might want a data type such as the following, called a **composite type** in Julia:\n\n\n\nIn this definition, we introduce a composite type consisting of three primitive type inside it: a `grammar`, an `age`, and a (social) `class`. The first is declared to be an integer, the second a floating-point number with 64 bits of precision, and the third a string.\n\n::: {.callout-note}\nThe keyword `mutable` is important in the type's definition. If we leave it out, any objects created with this type will be immutable, and cannot be changed once they've been created. We will see examples of this in the main chapters of these lecture notes.\n:::\n\nThink of a composite type such as this as a *template*. We can use and reuse the same template to create multiple instances, or **objects**, of that template. For example:\n\n\n\nThis will create two `Speaker` objects and store them in the variables `alice` and `bob`. The first instance has a grammar of type `1` (we haven't really specified yet what that means---but we will in the main chapters of these notes), the second a grammar of type `2`. The first has an age of `22.5` (which we might interpret as years), the second an age of `40.0`. Finally, the first speaker is defined to be middle-class, the second, lower-class.\n\n\n## Functions\n\nThe actual functionality of composite objects will be defined by **functions**, which manipulate those objects.\n\nFor example, suppose we want to implement a function that changes a speaker's grammar to `i` (from whichever value it happens to have at the moment), where `i` is some integer. This we can achieve with the following function. The function takes two **arguments**: a `Speaker` object, and `i`. It then modifies the speaker's `grammar` field to read `i`. (Fields are accessed using the `.` notation.)\n\n\n\nHere's a function that increments a speaker's age by one year:\n\n\n\n::: {.callout-note}\nBy convention, functions which modify things are appended with a `!` in their name in Julia. This is not mandatory, but is good practice, since looking at the function name immediately tells you whether the function modifies an object or not.\n:::\n\nFunctions do not need to manipulate objects created from composite types: they can do many other things, too. For example, the following function takes three integers and returns their sum:\n\n\n\nWe can then call the function like this:\n\n::: {#7c9ae325 .cell execution_count=49}\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n10\n```\n:::\n:::\n\n\nFunctions need not have return values---indeed, our `change_grammar!` function doesn't have one. Some functions also have no arguments, like the following function which simply prints the string `\"Hello, world!\"` to the screen:\n\n::: {#e0ac8877 .cell execution_count=50}\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, world!\n```\n:::\n:::\n\n\n## Constructors\n\n**Constructors** are special functions used to create objects from composite types. Recall that, above, we created a speaker like this:\n\n\n\nWhat if we want each speaker to have age 0 when they are created? This is easy to do with a constructor that supplies this default value. The constructor will have to have the same name as the composite type.\n\n\n\nWhat this constructor function does is to simply call the default constructor (which takes three values), supplying `0.0` as the new speaker's age.\n\n::: {.callout-note}\nThere is a shorter and possibly more intuitive way of definining this constructor:\n\n\n\n:::\n\nDefining a new constructor does not remove the default constructor. Hence we can \"birth\" a speaker at age 10, for example, if we want to:\n\n\n\n## Control flow\n\nPrograms often need to check whether some condition is fulfilled or not, and continue one way or another depending on that check's outcome. For example, suppose we want to implement a `class_trip` function that takes a speaker from their social class to the one immediately higher class. We could write something like the following:\n\n\n\n::: {.callout-note}\nNote the very crucial difference between `==` and `=`. The double equals sign is used for comparisons, the single one for assignments. Confusing these two is a very common source of beginner errors.\n:::\n\n\n## Loops\n\nPrograms also often need to carry out some action repetitively. For example, suppose we wish to define a function that takes an array of numbers of *arbitrary* length and returns the mean of the numbers in that array. Our function will need to take the sum over the entire array, then divide by the length of the array. One way of doing this is by using a `for` loop. (Note that `Array{Float64}` specifies that we expect, as input, an array of floating-point numbers, and that `length` is a function that returns the number of elements in an array.)\n\n::: {#a06434ec .cell execution_count=56}\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n28.4\n```\n:::\n:::\n\n\n::: {.callout-note}\nThis example is a bit silly, since Julia (of course) already has a ready-made function that takes sums over arrays: `sum`. But it serves to illustrate how `for` loops operate.\n:::\n\nAnother use case for a `for` loop might be the following. Suppose we have collected a number of `Speaker` objects in an array, and wish to print out the age of each speaker. This is easy to do:\n\n::: {#14154705 .cell execution_count=57}\n\n::: {.cell-output .cell-output-stdout}\n```\n22.5\n40.0\n80.8\n```\n:::\n:::\n\n\nHowever, there is an even better (a more \"Julian\", i.e. more idiomatic) solution. We first write a function that returns a speaker's age:\n\n\n\nOr using the shorter syntax:\n\n\n\nWe can then use the `.` affix to apply this function to each speaker in our array:\n\n::: {#8c41eba8 .cell execution_count=60}\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\n3-element Vector{Float64}:\n 22.5\n 40.0\n 80.8\n```\n:::\n:::\n\n\nThis returns a three-element vector containing the speakers' ages, but does not print it to the terminal. If we want the latter too, we just call `println`, broadcast over the array:\n\n\n\n## Array comprehensions\n\nAnother powerful feature of the Julia language are **array comprehensions**. An array comprehension is used to create an array by repeatedly executing a desired expression. For example, suppose we want to generate an array that consists of the squares of the first 100 natural numbers, including zero (so the array needs to contain $0^2 = 0$, $1^2 = 1$, $2^2 = 4$ and so on).\n\n::: {#946858b2 .cell execution_count=62}\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\n100-element Vector{Int64}:\n    0\n    1\n    4\n    9\n   16\n   25\n   36\n   49\n   64\n   81\n  100\n  121\n  144\n    ⋮\n 7744\n 7921\n 8100\n 8281\n 8464\n 8649\n 8836\n 9025\n 9216\n 9409\n 9604\n 9801\n```\n:::\n:::\n\n\nThe expression to be evaluated in an array comprehension can be arbitrarily complex; for example, it can be a function. Suppose we wanted (for whatever reason) to create an array that repeats the age of our speaker `alice` fifty times. We could accomplish this with the following array comprehension:\n\n::: {#a5e9500b .cell execution_count=63}\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\n50-element Vector{Float64}:\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n  ⋮\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n 22.5\n```\n:::\n:::\n\n\nYou will find more useful applications of array comprehensions in the main chapters; they are often the most elegant way of creating trajectories over entire populations of speakers, for example.\n\n\n## Preparing for the future\n\nGo ahead and install the following packages, which we will rely on later. *Plots* is used to draw figures, and *Agents* gives some useful functionality for agent-based models.\n\n\n\n",
    "supporting": [
      "basics_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}