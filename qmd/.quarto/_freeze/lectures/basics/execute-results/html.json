{
  "hash": "11003c60b3a8248ef45211c68941cafe",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Programming basics\"\ndate: 04/16/2024\nimage: \"../img/basics-image.png\"\ncategories:\n  - lecture\nformat:\n  revealjs:\n    output-file: basics-slides.html\n---\n\n## Programming in Julia\n\n- We will now dive straight into programming in Julia, starting with simple examples and concepts, progressing step-by-step to more complicated topics\n- To follow this lecture, you need to have a working Julia installation: see the homework on [Installing Julia](../homework/installing-julia.qmd)\n- For today, don't worry too much about whether what we do is useful -- what we are doing is establishing a *foundation* for later for the actually useful stuff...\n\n\n## Plan\n\n1. Variables and types\n1. Arrays and broadcasting\n1. Functions\n1. Custom types\n1. First look at random numbers\n1. Interpreted vs. compiled languages\n\n\n## Variables and assignments\n\n- In programming, a **variable** is a \"storage box\" that stores data for later use\n- The data is **assigned** to the variable using the `=` operator\n- Here, we assign the number 5 to a variable named `my_number`:\n\n::: {#4e8eb0e8 .cell execution_count=1}\n``` {.julia .cell-code}\nmy_number = 5\n```\n:::\n\n\n- We can now do things such as:\n\n::: {#14ad1cee .cell execution_count=2}\n``` {.julia .cell-code}\nmy_number + my_number\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n10\n```\n:::\n:::\n\n\n## Fundamental types\n\n- Variables can store different **types** of data:\n  - Integers: `1`, `2`, `-100`, ...\n  - Floating-point numbers (\"floats\"): `3.14`, `pi`, `1.0`, ...\n  - Booleans: `true`, `false`\n  - Strings: `\"John\"`, `\"Mary\"`\n  - Arrays: `[1, 2, 3, 4]`, `[1 2 3 4]`\n  - And some others... we'll meet them later\n\n\n## Arithmetic operations\n\n- Arithmetic operations are mostly self-explanatory. For example:\n\n::: {#182c125e .cell execution_count=3}\n``` {.julia .cell-code}\nnumber1 = 15\nnumber2 = 20\nnumber3 = 10*(number1 + number2) - number1/number2\nnumber3\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n349.25\n```\n:::\n:::\n\n\n## String concatenation\n\n- Julia overloads the `*` operator for strings too:\n\n::: {#19a43e58 .cell execution_count=4}\n``` {.julia .cell-code}\nstring1 = \"This \"\nstring2 = \"is a\"\nstring3 = \" sentence\"\nstring1 * string2 * string3 * \"!\"\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n\"This is a sentence!\"\n```\n:::\n:::\n\n\n## Arrays\n\n- An array is a (possibly multidimensional) collection of objects\n  - A one-dimensional array is a vector, a two-dimensional array is a matrix, and so on\n- Usually we work with arrays of numbers. They are easy to create:\n\n::: {#2eb49f42 .cell execution_count=5}\n``` {.julia .cell-code}\nmy_array = [10, 20, 30, 40]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n4-element Vector{Int64}:\n 10\n 20\n 30\n 40\n```\n:::\n:::\n\n\n## Accessing array contents\n\n- The elements of an array can be accessed one-by-one by referencing their location or **index** in the array:\n\n::: {#c7e84ead .cell execution_count=6}\n``` {.julia .cell-code}\nmy_array = [10, 20, 30, 40]\nmy_array[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n10\n```\n:::\n:::\n\n\nor\n\n::: {#e1744754 .cell execution_count=7}\n``` {.julia .cell-code}\nmy_array[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n20\n```\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Accessing array contents\n:::\n\n- The special keyword `end` fetches the last element:\n\n::: {#a1b0abea .cell execution_count=8}\n``` {.julia .cell-code}\nmy_array[end]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n40\n```\n:::\n:::\n\n\n- Arrays can also be subsetted:\n\n::: {#11846e60 .cell execution_count=9}\n``` {.julia .cell-code}\nmy_array[2:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n2-element Vector{Int64}:\n 20\n 30\n```\n:::\n:::\n\n\n## Broadcasting\n\n- Suppose I want to add `1` to each number in `my_array`\n- The following will **not** work:\n\n::: {#d720fa3d .cell execution_count=10}\n``` {.julia .cell-code}\nmy_array + 1\n```\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Broadcasting\n:::\n\n- Why? Because mathematically the operation \"add a scalar into a vector\" is undefined\n- To apply an operator **elementwise** to each element in an array, we can prefix the operator with a period. In Julia-speak, this is called **broadcasting**.\n\n::: {#c44999a6 .cell execution_count=11}\n``` {.julia .cell-code}\nmy_array .+ 1\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n4-element Vector{Int64}:\n 11\n 21\n 31\n 41\n```\n:::\n:::\n\n\n## Type mismatch\n\n- Why does the following not work?\n\n::: {#bc803e0c .cell execution_count=12}\n``` {.julia .cell-code}\nmy_string = \"My shoe size is: \"\nmy_number = 41\nmy_string * my_number\n```\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Type conversion\n:::\n\n- To make it work, we need to explicitly **convert** the integer into a string:\n\n::: {#a05ef7b2 .cell execution_count=13}\n``` {.julia .cell-code}\nmy_string = \"My shoe size is: \"\nmy_number = 41\nmy_string * string(my_number)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n\"My shoe size is: 41\"\n```\n:::\n:::\n\n\n## Functions\n\n- A **function**, sometimes also known as a **subroutine**, is a **reusable** piece of code that performs, well, some function...\n- We define it once and then can use it as many times as we like\n- A function can (but need not) take inputs -- these are known as the function's **arguments**\n- A function can (but need not) give an output -- this is known as the function's **return value**\n\n\n## Functions: example\n\n- Here is a function that takes two arguments, an array and a scalar number, and adds the scalar to each element of the array\n- I'm calling the function `add_elementwise`\n\n::: {#e4ea3040 .cell execution_count=14}\n``` {.julia .cell-code}\nfunction add_elementwise(array, scalar)\n  result = array .+ scalar\n  return result\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nadd_elementwise (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Functions: example\n:::\n\n- We can now **call** the function on particular arrays and numbers:\n\n::: {#184dec6c .cell execution_count=15}\n``` {.julia .cell-code}\nmy_array = [10, 20, 30, 40]\nadd_elementwise(my_array, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n4-element Vector{Int64}:\n 11\n 21\n 31\n 41\n```\n:::\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Functions: example\n:::\n\n::: {#bdc45c0e .cell execution_count=16}\n``` {.julia .cell-code}\nadd_elementwise(my_array, -23.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n4-element Vector{Float64}:\n -13.5\n  -3.5\n   6.5\n  16.5\n```\n:::\n:::\n\n\n## Exercise {.ex-slide}\n\nWrite a function with the following properties:\n\n- The function's name is `announce_age`\n- The function takes two arguments, the first a person's name, the second a number that is that person's age\n- The function's return value is a string which announces the person's age in this format: `\"John is 40 years old\"`\n\n::: {.content-visible when-format=\"revealjs\"}\n## Exercise {.ex-slide}\n:::\n\n::: {.callout-tip collapse=true title=\"Answer\"}\nHere is the function definition:\n\n::: {#363c05d2 .cell execution_count=17}\n``` {.julia .cell-code}\nfunction announce_age(name, age)\n  return name * \" is \" * string(age) * \" years old\"\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nannounce_age (generic function with 1 method)\n```\n:::\n:::\n\n\nLet's test it:\n\n::: {#d4ea0e68 .cell execution_count=18}\n``` {.julia .cell-code}\nannounce_age(\"John\", 40)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n\"John is 40 years old\"\n```\n:::\n:::\n\n\n:::\n\n\n## Custom types (\"classes\" and \"objects\")\n\n- Idea of **object-oriented programming** (OOP): we can make custom types (**classes**) which are instantiated as **objects**\n  - Programming ABMs in a language that does not support this would be very cumbersome\n- In Julia, custom types are defined by way of a special keyword, `struct`\n- A custom type is effectively a combination of variables called the type's **fields**\n- If the fields need to be modifiable later in the program, we use `mutable struct` instead of `struct`\n\n\n## Custom types: example\n\n- Suppose we want to represent a person by way of their name, their age and their shoe size\n- Since these fields (at least age) need to be modifiable, we use a `mutable struct`:\n\n::: {#949ebc3b .cell execution_count=19}\n``` {.julia .cell-code}\nmutable struct Person\n  name::String\n  age::Int\n  shoesize::Float64\nend\n```\n:::\n\n\n::: {.content-visible when-format=\"revealjs\"}\n## Custom types: example\n\n::: {#c339af1b .cell execution_count=20}\n``` {.julia .cell-code}\nmutable struct Person\n  name::String\n  age::Int\n  shoesize::Float64\nend\n```\n:::\n\n\n:::\n\n- Here,\n  - `name::String` means the field called `name` is of type string, etc.\n  - `Int` is an integer\n  - in `Float64`, the number specifies the precision of the floating-point number (related to how many decimals it can store)\n\n::: {.content-visible when-format=\"revealjs\"}\n## Custom types: example\n:::\n\n- We can now **construct** an instance of the `Person` custom type, a `Person` object, and store it in a variable:\n\n::: {#cea3dcf3 .cell execution_count=21}\n``` {.julia .cell-code}\njane = Person(\"Jane\", 35, 39.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nPerson(\"Jane\", 35, 39.5)\n```\n:::\n:::\n\n\n- To **access** the fields of an object, we use the following dot syntax:\n\n::: {#193407b8 .cell execution_count=22}\n``` {.julia .cell-code}\njane.name\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n\"Jane\"\n```\n:::\n:::\n\n\n## Exercise {.ex-slide}\n\nWrite three functions:\n\n1. A function that takes a `Person` object as argument and returns their shoe size\n1. A function that takes a `Person` object and a string as argument, and sets the person's name to be the string supplied as argument\n1. A function that increments a `Person` object's age by one\n \n::: {.content-visible when-format=\"revealjs\"}\n## Exercise {.ex-slide}\n:::\n\n::: {.callout-tip collapse=true title=\"Answer\"}\n\n::: {#0a363aff .cell execution_count=23}\n``` {.julia .cell-code}\nfunction get_shoesize(x)\n  return x.shoesize\nend\n\nfunction set_name(x, y)\n  x.name = y\nend\n\nfunction become_older(x)\n  x.age = x.age + 1\nend\n```\n:::\n\n\n:::\n\n\n## Explicit type specifications\n\nNote that it is possible (and often good practice) to explicitly set the types of function arguments:\n\n::: {#172d6db3 .cell execution_count=24}\n``` {.julia .cell-code}\nfunction get_shoesize(x::Person)\n  return x.shoesize\nend\n\nfunction set_name(x::Person, y::String)\n  x.name = y\nend\n\nfunction become_older(x::Person)\n  x.age = x.age + 1\nend\n```\n:::\n\n\n## Getters and setters\n\n- Functions that return an object's field are sometimes known as **getters**. Functions that set a field are known as **setters**.\n- In Julia, it is customary to append an exclamation point to the name of every setter function. This is to warn users of the function that the function modifies something in the object.\n- Thus, we would rather write:\n\n::: {#7e31cb3b .cell execution_count=25}\n``` {.julia .cell-code}\nfunction set_name!(x::Person, y::String)\n  x.name = y\nend\n```\n:::\n\n\n## Array comprehensions\n\n- What if we wanted to create 3 `Person`s? Easy:\n\n::: {#1b2b9e8f .cell execution_count=26}\n``` {.julia .cell-code}\nperson1 = Person(\"Jane\", 35, 39.5)\nperson2 = Person(\"John\", 44, 43.0)\nperson3 = Person(\"Bob\", 65, 42.33)\n```\n:::\n\n\n- What if we wanted to create 1000 `Person`s?\n\n::: {.content-visible when-format=\"revealjs\"}\n## Array comprehensions\n:::\n\n- Here we can use a powerful feature known as an **array comprehension**. The following creates 1000 persons, each with the same default fields (we'll later see how to modify this), and places them in an array. The array is returned and stored in the `population` variable:\n\n::: {#f2f1d7b5 .cell execution_count=27}\n``` {.julia .cell-code}\npopulation = [Person(\"M. Musterperson\", 0, 0.0) for i in 1:1000]\n```\n:::\n\n\n- The `i` variable is a dummy variable that only exists for the duration of the array comprehension.\n\n::: {.content-visible when-format=\"revealjs\"}\n## Array comprehensions\n:::\n\n- We can now access individual persons by indexing them from the array:\n\n::: {#145cda64 .cell execution_count=28}\n``` {.julia .cell-code}\npopulation[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nPerson(\"M. Musterperson\", 0, 0.0)\n```\n:::\n:::\n\n\n- We can also access their fields:\n\n::: {#ee2de3dd .cell execution_count=29}\n``` {.julia .cell-code}\npopulation[1].name\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n\"M. Musterperson\"\n```\n:::\n:::\n\n\n- And we can set them:\n\n::: {#f7e40df6 .cell execution_count=30}\n``` {.julia .cell-code}\nset_name(population[1], \"Bob the Builder\")\npopulation[1].name\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n\"Bob the Builder\"\n```\n:::\n:::\n\n\n## Broadcasting functions\n\n- Earlier, we saw how operators such as `+` can be broadcast over arrays\n- The same can be done with functions, for example:\n\n::: {#3f325a48 .cell execution_count=31}\n``` {.julia .cell-code}\nalice = Person(\"Alice\", 25, 40.0)\nbob = Person(\"Robert\", 55, 45.0)\ncarly = Person(\"Carly\", 55, 39.0)\n\nspeakers = [alice, bob, carly]\n\nget_shoesize.(speakers)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3-element Vector{Float64}:\n 40.0\n 45.0\n 39.0\n```\n:::\n:::\n\n\n## Random numbers\n\n- To get a (pseudo)random number from between 0 and 1, simply call:\n\n::: {#bc543161 .cell execution_count=32}\n``` {.julia .cell-code}\nrand()\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n0.25807708571323906\n```\n:::\n:::\n\n\n## Exercise {.ex-slide}\n\nHow can you obtain a random number from between 0 and 50?\n\nHow about between 50 and 100?\n\n::: {.content-visible when-format=\"revealjs\"}\n## Exercise {.ex-slide}\n:::\n\n::: {.callout-tip collapse=true title=\"Answer\"}\nRandom number from between 0 and 50:\n\n::: {#07347be5 .cell execution_count=33}\n``` {.julia .cell-code}\n50*rand()\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n5.724595376655711\n```\n:::\n:::\n\n\nRandom number from between 50 and 100:\n\n::: {#bb7ddad5 .cell execution_count=34}\n``` {.julia .cell-code}\n50 + 50*rand()\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n93.73491793451834\n```\n:::\n:::\n\n\n:::\n\n\n## Comments\n\n- To improve code readability, we insert comments (these are ignored by the compiler)\n- Single-line comment:\n\n::: {#7ca13d8c .cell execution_count=35}\n``` {.julia .cell-code}\n# the following variable stores my shoe size\nshoesize = 41.5\n```\n:::\n\n\n- Multi-line comment:\n\n::: {#dfc9717f .cell execution_count=36}\n``` {.julia .cell-code}\n#=\nThe following variable\nstores my shoe size\n=#\nshoesize = 41.5\n```\n:::\n\n\n## Packages\n\n- Basic Julia functionality is extended by **packages**\n- These are installed through a package manager called **Pkg**\n- E.g. to install the *Agents* package (and all its dependencies), we issue these commands:\n\n::: {#7496f327 .cell execution_count=37}\n``` {.julia .cell-code}\nusing Pkg\nPkg.add(\"Agents\")\n```\n:::\n\n\n- Once the package has been installed, we can load it by:\n\n::: {#32413e4f .cell execution_count=38}\n``` {.julia .cell-code}\nusing Agents\n```\n:::\n\n\n## Why is Julia sometimes slow?\n\n::::: {.content-visible when-format=\"revealjs\"}\n:::: {.columns}\n::: {.column width=\"60%\"}\n![](../img/first-transistor.jpg){height=450px}\n:::\n::: {.column width=\"40%\"}\n- CPUs and computer memory consist of binary devices, they are either \"on\" or \"off\"^[Photo of replica of the first transistor from [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Replica-of-first-transistor.jpg). Public domain.]\n:::\n::::\n\n\n## Why is Julia sometimes slow?\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n- But humans write source code which is understandable to humans (well, mostly anyway...)^[Cartoon from [geek & poke](https://geek-and-poke.com/geekandpoke/2015/10/9/simply-explained). CC-BY-3.0.]\n:::\n::: {.column width=\"60%\"}\n![](../img/geekpoke.png){height=600px}\n:::\n::::\n\n\n## Why is Julia sometimes slow?\n\n- So translation is needed.\n- Imagine you need to translate cooking recipes (algorithms) from English (source code) to Spanish (machine code). You have roughly two options:\n  - Every time a particular instruction is called for, you translate it anew (**interpreted languages**)\n  - You translate the entire recipe and give it to the cook (the CPU) (**compiled languages**)\n:::::\n\n::::: {.content-visible unless-format=\"revealjs\"}\n\n- CPUs and computer memory consist of binary devices, they are either \"on\" or \"off\"^[Photo of replica of the first transistor from [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Replica-of-first-transistor.jpg). Public domain.]\n\n![](../img/first-transistor.jpg){height=450px}\n\n- But humans write source code which is understandable to humans (well, mostly anyway...)^[Cartoon from [geek & poke](https://geek-and-poke.com/geekandpoke/2015/10/9/simply-explained). CC-BY-3.0.]\n\n![](../img/geekpoke.png){height=600px}\n\n- So translation is needed.\n- Imagine you need to translate cooking recipes (algorithms) from English (source code) to Spanish (machine code). You have roughly two options:\n  - Every time a particular instruction is called for, you translate it anew (**interpreted languages**)\n  - You translate the entire recipe and give it to the cook (the CPU) (**compiled languages**)\n:::::\n\n\n## Why is Julia sometimes slow?\n\n- Julia is a **just-in-time (JIT) compiled language**\n- Meaning roughly: code blocks are compiled as they are encountered\n- Compiled code is stored for later use\n- Initial compilation takes time\n\n\n## Why is Julia sometimes fast?\n\n- However, all subsequent executions are fast!\n- This is because the translations have already been made and stored\n- Furthermore, code can be optimized during the initial compilation\n  - Since your Spanish cook (the CPU) knows that \"cdta.\" stands for \"cucharadita\" (teaspoon), the compiler can use the shorter translation instead of the long one\n\n\n## Speed in practice\n\n- In practice, these differences mean that:\n  - Running a function once may be quicker in Python\n  - Running the same function 1000 times will be quicker in Julia\n- A lot of the attractiveness of Julia for ABM comes from this fact -- that it compiles into fast machine code on many different processor architectures\n\n![](../img/fight.png){height=200px}\n\n\n## Summary\n\n- Here you've learned some of the basics of the Julia language\n- There is much more... we will learn it as we go along\n- We will make heavy use of array comprehensions, functions and custom types, so make sure you understand these concepts\n- You get to practice them in this week's [homework](../homework/fly.qmd)\n\n",
    "supporting": [
      "basics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}